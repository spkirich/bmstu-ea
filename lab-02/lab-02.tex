\documentclass[oneside, a4paper, 12pt]{report}

\usepackage[left=3cm, right=1cm, top=2cm, bottom=2cm]{geometry}

\usepackage{setspace}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage{misccorr}
\usepackage{indentfirst}

\usepackage{graphicx}
\usepackage{listings}

\onehalfspacing
\lstset{captionpos=b}

\title{
    Отчёт по лабораторной работе № 2 по курсу <<Архитектура ЭВМ>>
}

\author{Сергей Кириченко, ИУ7-51Б}

\begin{document}

\maketitle
\tableofcontents

\chapter{Введение}

\section{Цели работы}

Основная цель работы -- ознакомиться с особенностями архитектуры,
принципами функционирования и построения суперскалярных конвейерных
микропроцессоров.

Дополнительная цель работы -- получить представление о принципах
проектирования и верификации сложных цифровых устройств с помощью
языка описания аппаратуры SystemVerilog и ПЛИС.

\section{Основные теоретические сведения}

RISC-V является открытым современным набором команд, который может
использоваться для построения как микроконтроллеров, так и
высокопроизводительных микропроцессоров. В связи с такой широкой
областью применения он допускает существенную вариативность. Таким
образом, термин RISC-V фактически является названием семейства
различных наборов команд.

В данной работе рассматривается набор команд RV32I, который
включает в себя основные команды 32-битной целочисленной
арифметики.

Набор команд RV32I предполагает использование следующих 32-битных
регистров:

\begin{itemize}
    \item общего назначения -- \texttt{x0}-\texttt{x31};
    \item адреса следующей команды -- \texttt{pc}.
\end{itemize}

Регистр \texttt{x0} всегда содержит значение \texttt{0x00}. Запись
в него не производит никакого эффекта.

Архитектура RV32I предполагает плоское линейное 32-битное адресное
пространство. Минимальной адресуемой единицей информации является
байт. Используется порядок байтов от младшего к старшему (Little
Endian), то есть младший байт 32-битного слова находится по
младшему адресу (по смещению 0). Отсутствует разделение на адресные
пространства команд, данных и ввода-вывода. Распределение областей
памяти между различными устройствами (ОЗУ, ПЗУ, устройствами
ввода-вывода) определяется реализацией.

Большинство команд RV32I являются трехадресными. Они выполняют
операции над двумя заданными явно операндами и сохраняют результат
в регистре. Операндами могут являться регистры или константы, явно
заданные в коде команды. Операнды всех команд (кроме команды
\texttt{auipc}) задаются явно.

Вообще, команды RV32I можно разделить на следующие категории:

\begin{itemize}

    \item команды обработки данных:
    
    \begin{itemize}
        \item арифметические и логические команды;
        \item команды сравнения;
        \item команды сдвига;
        \item команды формирования значения в старшей части
        регистра;
    \end{itemize}

    \item команды передачи управления:

    \begin{itemize}
        \item команды безусловного перехода с сохранением адреса
        возврата;
        \item команды условного перехода;
        \item команды доступа к памяти;
        \item команды загрузки;
        \item команды сохранения;
    \end{itemize}

    \item системные команды.

\end{itemize}

\chapter{Исследование исходного кода программы}

\section{Исходный код}

В данной работе была исследована следующая программа:

\begin{lstlisting}[caption=Исходный код исследуемой программы]
.section .text
.globl _start;

elem_count = 8
elem_bytes = 4
elem_group = 2

_start:
    la x1, _elems
    addi x20, x1, elem_count * elem_bytes
    add x31, x0, x0

loop_proc:
    lw x2, 0(x1)
    add x31, x31, x2 #!
    lw x3, 4(x1)
    add x31, x31, x3
    addi x1, x1, elem_group * elem_bytes
    bne x1, x20, loop_proc
    addi x31, x31, 1

loop_halt:
    j loop_halt

.section .data

_elems:
    .4byte 0x01
    .4byte 0x02
    .4byte 0x03
    .4byte 0x04
    .4byte 0x05
    .4byte 0x06
    .4byte 0x07
    .4byte 0x08
\end{lstlisting}

\section{Поясняющий псевдокод}

Один из преподавателей кафедры ИУ7 МГТУ им. Баумана однажды сказал,
что оператор \texttt{goto} он воспринимает как личное оскорбление.
Естественно, в данной работе <<прыжки>> по коду не рассматриваются
столь категорично, однако их наличие существенно осложняют его
восприятие. Во избежание этого исследуемая программа может быть
пояснена следующим псевдокодом:

\begin{lstlisting}[
    caption=Псевдокод исследуемой программы, language=C
]
#define elem_count 8
#define elem_bytes 4
#define elem_group 2

int _elems =
{
    0x01,
    0x02,
    0x03,
    0x04,
    0x05,
    0x06,
    0x07,
    0x08,
};

void _start()
{
    // Lower bound
    int *x1 = _elems;

    // Upper bound
    int *x20 = x1 + elem_count;

    // Sum
    int x31 = 0;

    do
    {
        int x2 = x1[0];
        x31 += x2;

        int x3 = x1[1];
        x31 += x3;

        x1 += elem_group;
    }
    while(x1 != x20);

    x31++;

    while (1)
    {
        // Halt forever...
    }
}
\end{lstlisting}

Теперь очевидно, что в конце выполнения данной программы в регистре
\texttt{x31} будет находиться значение \texttt{0x25}.

\section{Дизассемблированный код}

В результате сборки и последующего дизассемблирования был получен
следующий листинг:

\begin{lstlisting}[
    caption=Дизассемблированный код исследуемой программы
]
80000000 <_start>:
80000000: 00000097 auipc    x1,0x0
80000004: 03008093 addi     x1,x1,48 # 80000030 <_elems>
80000008: 02008a13 addi     x20,x1,32
8000000c: 00000fb3 add      x31,x0,x0

80000010 <loop_proc>:
80000010: 0000a103 lw       x2,0(x1)
80000014: 002f8fb3 add      x31,x31,x2
80000018: 0040a183 lw       x3,4(x1)
8000001c: 003f8fb3 add      x31,x31,x3
80000020: 00808093 addi     x1,x1,8
80000024: ff4096e3 bne      x1,x20,80000010 <loop_proc>
80000028: 001f8f93 addi     x31,x31,1

8000002c <loop_halt>:
8000002c: 0000006f jal      x0,8000002c <loop_halt>
\end{lstlisting}

\chapter{Исследование процесса выполнения программы}

\chapter{Оптимизация программы}

\chapter{Заключение}

В ходе выполнения данной работы были изучены особенности
архитектуры, принципы функционирования и построения суперскалярных
конвейерных микропроцессоров.

Также были рассмотрены некоторые принципы проектирования и
верификации сложных цифровых устройств с помощью языка описания
аппаратуры SystemVerilog и ПЛИС.

\end{document}
